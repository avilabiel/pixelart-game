{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rIC = exports.now = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\")); // adapted FROM: https://github.com/facebook/react/blob/3019210df2b486416ed94d7b9becffaf254e81c4/src/renderers/shared/ReactDOMFrameScheduling.js\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar hasNativePerformanceNow = (typeof performance === \"undefined\" ? \"undefined\" : (0, _typeof2.default)(performance)) === 'object' && typeof performance.now === 'function';\nvar now;\nexports.now = now;\n\nif (hasNativePerformanceNow) {\n  exports.now = now = function now() {\n    return performance.now();\n  };\n} else {\n  exports.now = now = function now() {\n    return Date.now();\n  };\n} // TODO: There's no way to cancel, because Fiber doesn't atm.\n\n\nvar rIC;\nexports.rIC = rIC;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  exports.rIC = rIC = function rIC(frameCallback) {\n    setTimeout(function () {\n      frameCallback({\n        timeRemaining: function timeRemaining() {\n          return Infinity;\n        }\n      });\n    });\n    return 0;\n  };\n} else if (typeof requestIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback.\n  var scheduledRAFCallback = null;\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n  var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n  var frameDeadlineObject;\n\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        return frameDeadline - performance.now();\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // Fallback to Date.now()\n        return frameDeadline - Date.now();\n      }\n    };\n  } // We use the postMessage trick to defer idle work until after the repaint.\n\n\n  var messageKey = \"__reactIdleCallback$\".concat(Math.random().toString(36).slice(2));\n\n  var idleTick = function idleTick(event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  }; // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n\n\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function animationTick(rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      } // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n\n\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n\n    frameDeadline = rafTime + activeFrameTime;\n\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n\n    var callback = scheduledRAFCallback;\n    scheduledRAFCallback = null;\n\n    if (callback !== null) {\n      callback(rafTime);\n    }\n  };\n\n  exports.rIC = rIC = function rIC(callback) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n\n    return 0;\n  };\n} else {\n  exports.rIC = rIC = requestIdleCallback;\n}","map":{"version":3,"sources":["/Users/Gabriel/workspace/Personal/pixelart-game/node_modules/sprite-react/lib/ReactDOMFrameScheduling.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","rIC","now","_typeof2","ExecutionEnvironment","hasNativePerformanceNow","performance","default","Date","canUseDOM","frameCallback","setTimeout","timeRemaining","Infinity","requestIdleCallback","scheduledRAFCallback","scheduledRICCallback","isIdleScheduled","isAnimationFrameScheduled","frameDeadline","previousFrameTime","activeFrameTime","frameDeadlineObject","messageKey","concat","Math","random","toString","slice","idleTick","event","source","window","data","callback","addEventListener","animationTick","rafTime","nextFrameTime","postMessage","requestAnimationFrame"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rIC = exports.now = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\n// adapted FROM: https://github.com/facebook/react/blob/3019210df2b486416ed94d7b9becffaf254e81c4/src/renderers/shared/ReactDOMFrameScheduling.js\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar hasNativePerformanceNow = (typeof performance === \"undefined\" ? \"undefined\" : (0, _typeof2.default)(performance)) === 'object' && typeof performance.now === 'function';\nvar now;\nexports.now = now;\n\nif (hasNativePerformanceNow) {\n  exports.now = now = function now() {\n    return performance.now();\n  };\n} else {\n  exports.now = now = function now() {\n    return Date.now();\n  };\n} // TODO: There's no way to cancel, because Fiber doesn't atm.\n\n\nvar rIC;\nexports.rIC = rIC;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  exports.rIC = rIC = function rIC(frameCallback) {\n    setTimeout(function () {\n      frameCallback({\n        timeRemaining: function timeRemaining() {\n          return Infinity;\n        }\n      });\n    });\n    return 0;\n  };\n} else if (typeof requestIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback.\n  var scheduledRAFCallback = null;\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n  var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n  var frameDeadlineObject;\n\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        return frameDeadline - performance.now();\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // Fallback to Date.now()\n        return frameDeadline - Date.now();\n      }\n    };\n  } // We use the postMessage trick to defer idle work until after the repaint.\n\n\n  var messageKey = \"__reactIdleCallback$\".concat(Math.random().toString(36).slice(2));\n\n  var idleTick = function idleTick(event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  }; // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n\n\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function animationTick(rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      } // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n\n\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n\n    frameDeadline = rafTime + activeFrameTime;\n\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n\n    var callback = scheduledRAFCallback;\n    scheduledRAFCallback = null;\n\n    if (callback !== null) {\n      callback(rafTime);\n    }\n  };\n\n  exports.rIC = rIC = function rIC(callback) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n\n    return 0;\n  };\n} else {\n  exports.rIC = rIC = requestIdleCallback;\n}"]},"metadata":{},"sourceType":"script"}